---
layout: presentation
title: Programmation fonctionnelle
presenter: true
permalink: /presentations/progfun.html
---
        

???
* La théorie de la programmation fonctionnelle
* Decouvrir les principaux pattern
* Voir la progfun dans la vraie vie


---
layout: false
class: middle, inverse, bigText

> "La programmation fonctionnelle est un paradigme de programmation qui considère le calcul en tant qu'évaluation de fonctions mathématiques."

Source : [Wikipedia](https://fr.m.wikipedia.org/wiki/Transparence_r%C3%A9f%C3%A9rentielle)


---
layout: false
class: bigText

##Programmation fonctionnelle pure
* Tout est fonction
* Pas d'affectation (mutation de variable)
* Transparence référentielle

???
→ Facilite grandement les tests et la réutilisabilité <br/>
→ Language plus proche des spécifications : on explique ce que ça doit faire, pas comment le faire <br/>
→ Parallélisation plus simple

Mais pas évident pour certains problèmes (gestion d'état...) comme l'informatique de gestion.


--

##Programmation fonctionnelle impure
* Affectations possibles
* Possibilité de travailler en orienté objet
* Utilisation de programmation impérative et fonctionnelle dans le même language
* Limiter au maximum les effets de bords

???

<hr/>
→ Java 8 <br/>
→ Scala







---
layout: true
class: center, middle, inverse
---
name: functions

#Programmer avec des fonctions ?

???

Voyons quelques grand principes de la programmation fonctionnelle.

---

#C'est quoi une fonction ?
---

#Fonction

> Relation qui, à chaque élément de son ensemble de départ, associe au plus une image.

--

# x → f(x)

--

# f : x → (4 × x) + 2

---
layout: false
class: bigText

# Transparence référentielle

> "La transparence référentielle est une propriété des expressions d'un langage de programmation qui fait qu'une expression peut être remplacée par son résultat sans changer le comportement du programme."

Source : [Wikipedia](https://fr.m.wikipedia.org/wiki/Transparence_r%C3%A9f%C3%A9rentielle)

---
class: bigTex2t

# Transparence référentielle


```java
Si      f = x → g(x) + g(x)
Alors   f = x → 2 × g(x)
```

--

Sauf si

```java
int n = 2;
int g(int x) {
    n = n + x;
    return n;
}
```

```java
        f¹(3) = g(3) + g(3) = 5 + 8 = 13
        f²(3) = 2 × g(3) = 2 × 5 = 10
```

→ Pas d'effet de bord         <br/>
→ Pas d'assignation

???

→ Préfigure CQRS (Command and Query Resposibility Segregation)  <br/>
→ Possibilité de faire de l'évaluation lazy (mot clé Scala)     <br/>


---
#Lazyness

```scala
scala> val x = { println("compute X"); 15 }
compute X
x: Int = 15

scala> lazy val y = { println("compute Y"); 13 }
y: Int = <lazy>

scala> x
res2: Int = 15

scala> y
compute Y
res3: Int = 13

scala> y
res4: Int = 13
```

Source : [Stackoverflow](http://stackoverflow.com/questions/7484928/what-does-a-lazy-val-do)

???

Si on est certain qu'une fonction donnera toujours le même résultat, pas besoin de l'évaluer plusieurs fois, ni de l'évaluer prématurément.

En scala, mot clé lazy obligatoire.


PS : super le REPL en Scala (ça arrive en Java 9)




---
# Stream

Scala :

```scala
scala> val stream = (1 to 100000000).toStream
stream: scala.collection.immutable.Stream[Int] = Stream(1, ?)
```

???
Possibilité de faire une collection de longueur infinie sans saturer la mémoire.
Chaque itération sera évaluée uniquement lorsque nécessaire

? = non évalué


--

Java :

```java
IntStream.iterate(0, i -> i + 1)
        .limit(10000000)
        .forEach(System.out::println);
```

???

Possible aussi en java







---
# Les fonctions d'ordre supérieur
## En paramètre
Java:
```java
static int maMethode(IntBinaryOperator op){
    return op.applyAsInt(5, 10);
}
```
Scala:
```scala
def maMethode(uneFonction: (int, int) => int) {
    return uneFonction(5,10);
}
```
Javascript:
```javascript
app.get('/', function(req, res) {...});
```

---
# Les fonctions d'ordre supérieur
## En retour
Java:
```java
public IntFunction<int> createAdder(int step){
    IntFunction<int> addFunction = (a) -> {return a+step};
    return addFunction;
}
IntFunction<int> addOne = createAdder(1);
addOne(4) //5
```
Scala:
```scala
def createAdder(step: Integer) = (a: Integer) => {a + step};
val addOne = createAdder(1);
addOne(4)
```
Javascript:
```javascript
function createAdder(step) {
    return function(a){return a+step;}
}
var addOne = createAdder(1);
addOne(4) //5
```


---
# Le currying

Scala:
```scala
def createAdder(step: Integer) = (a: Integer) => {a + step};
val addOne = createAdder(1);
addOne(4)
```

--

```scala
def createAdder(step: Integer) = (a: Integer) => {a + step};
createAdder(1)(4) //5
```




---
layout: false
class: middle, inverse, bigText

> "Functional programming is expression-oriented programming. A functional program is not a sequence of instructions, but a single, referentially transparent expression. Computation proceeds by substitution."

.small[Source : [Guerrilla Guide to Pure Functional Programming](http://jvmblog.com/post/35474017210/guerrilla-guide-to-pure-functional-programming)]



---
#Comment travailler sans assignations ?


<Insérer quelques exemples>


---
layout: true
class: center, middle, normal

---
#Merci de votre attention

---
layout: false
class: left, middle, normal

# Sources
- ["Programmation Fonctionnelle en HOPE"](http://www.labri.fr/perso/billaud/travaux/hope.pdf) par Michel Billaud
- ["The Guerilla Guide to Functional Programming"](https://docs.google.com/file/d/0B6Pvyu_QqshwYmU1OTg0OGEtMTMwMC00YmQ3LWIxY2MtYzdiMDNiM2QzNjZh/edit?hl=en) par Runar Oli Bjarnason
- ["Functional Programming is the new black"](https://speakerdeck.com/elise_huard/functional-programming-is-the-new-black)  par Elise Huard
- [La page wikipedia sur la programmtion fonctionnelle](http://fr.wikipedia.org/wiki/Programmation_fonctionnelle)
